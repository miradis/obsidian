> Создание экземпляра

Каждое приложение начинается с создание при помощью команды Vue

```
var vm = new Vue({  
// опции  
})
```
При создание экземпляра нужно задать [[список опции]].  Для создание корневого экземпляра Vue можно прописать команду new Vue, опционально организованного в  дерево вложенных, повторно используемых компонентов. Например дерево компонентов для TODO list.Пример:

```
Корневой экземпляр  
└─ TodoList  
├─ TodoItem  
│ ├─ TodoButtonDelete  
│ └─ TodoButtonEdit  
└─ TodoListFooter  
├─ TodosButtonClear  
└─ TodoListStatistics
```
Подробности о [[системе компонентов]].

> Данные и методы

Все свойства компонента прописываются в опции data.  Все изменения, которые будут происходить с свойствами в опции data, будут сразу менять представление приложения

```
// Наш объект data  
var data = { a: 1 }  
  
// Объект добавляется в экземпляр Vue  
var vm = new Vue({  
data: data  
})  
  
// Получение свойства из экземпляра  
// возвращает то же значение из исходных данных  
vm.a === data.a // => true  
  
// Изменение свойства экземпляра  
// влияет на оригинальные данные  
vm.a = 2  
data.a // => 2  
  
// ... и наоборот  
data.a = 3  
vm.a // => 3
```

Когда значение меняется, представление будет переотрисована. Но свойства в data будут реактивными, только в том случае, если они существовали на момент создания экземпляра. Это значит ,если добавить новое свойство, то изменение в b не будет изменяться. Чтобы решить данную ситуацию, нужно изначально прописать его в опции data как пустое значение. Пример: 

```
vm.b = 'hi'




//Решение
data: {  
newTodoText: '',  
visitCount: 0,  
hideCompletedTodos: false,  
todos: [],  
error: null  
}
```
Существует метод или команда, которая останавливает  отслеживание изменение свойств. 


```
var obj = {  
foo: 'bar'  
}  
  
Object.freeze(obj)  
  
new Vue({  
el: '#app',  
data: obj  
})




<div id="app">  
<p>{{ foo }}</p>  
<!-- мы теперь не можем обновить `foo`! -->  
<button v-on:click="foo = 'baz'">Изменить</button>  
</div>
```

Помимо свойств объекта, существует  служебные свойства  и методов у экземпляра Vue.  Их имена начинаются с префикса $, чтобы отличаться от пользовательских свойств. Например: 


```
var data = { a: 1 }  
var vm = new Vue({  
el: '#example',  
data: data  
})  
  
vm.$data === data // => true  
vm.$el === document.getElementById('example') // => true  
  
// $watch — это метод экземпляра  
vm.$watch('a', function (newValue, oldValue) {  
// Этот коллбэк будет вызван, когда изменится `vm.a`  
})
```

> Хуки жизненного цикла экземпляра

Каждый компонент имеет свой жизненный цикл, то есть проходит через несколько шагов. Например: настраивает наблюдение за данными, компилирует шаблон, монтирует экземпляр в DOM, обновляет DOM при изменении данных. Между этими  шагами, вызываются методы, их называют хуки жизненного цикла, с помощью которых можно выполнять свой код на определенных этапах.
Например: хук created можно выполнять после создания экземпляра. Код:

```
new Vue({  
data: {  
a: 1  
},  
created: function () {  
// `this` указывает на экземпляр vm  
console.log('Значение a: ' + this.a)  
}  
})  
// => "Значение a: 1"
```

Также существует и другие хуки жизненного цикла: monted, updated, destroyed. Все хуки работают с переменной this, чтобы работать с свойствами вызывающего экземпляра. 

> Не используйте [стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions) в свойствах экземпляра и в коллбэках, например `created: () => console.log(this.a)` или `vm.$watch('a', newVal => this.myMethod())`. Так как стрелочные функции не имеют собственного `this`, то `this` в коде будет обрабатываться как любая другая переменная и её поиск будет производиться в областях видимости выше до тех пор пока не будет найдена, часто приводя к таким ошибкам, как `Uncaught TypeError: Cannot read property of undefined` или `Uncaught TypeError: this.myMethod is not a function`.

> Диаграмма жизненного цикла


![[Pasted image 20230925152054.png]]

Следующая часть: [[Синтаксис шаблонов]]